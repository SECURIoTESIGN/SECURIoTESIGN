#include "Report.h"

Report::Report()
{

}

using namespace std;

void Report::formatReport_for_Consle(string request_id, int flag, string algo_name1, string algo_name2, string algo_name3, string algo_name4, string algo_name5, string algo_name6, string Re_6, string Re_7, string Re_8, string Re_9, string Re_10, string Re_11, string Re_12, string Re_13, string Re_14, string Re_15)
{

        if(flag == 1)
        {
                std::cout << endl << endl;
                std::cout << "\n\t A DETAILED REPORT ON THE RESULTS OF THE REQUEST OF USER WITH REQUEST ID No.: " << request_id <<endl <<endl;
                std::cout << "   This report consists of brief information about the recommended Lightweight Cryptographic Algorithms,\n";
                std::cout << "   and where applicable, it provides information on where to find the algorithms. The report also inclu-\n";
                std::cout << "   des some security measures needed to be taken in order to meet the remaining security requirements \n";
                std::cout << "   that were generated by the Security Requirement Elicitation tool to which no security mechanisms and  \n";
                std::cout << "   algorithms have been recommended.\n";


                std::cout << endl;

                std::cout << "\n\  THE RECOMMENDED ALGORITHMS " << endl <<endl;

                int counter = 0;
                 if(!algo_name1.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name1 << ":- ";
                     cipher_Info1( algo_name1);
                 }
                 if(!algo_name2.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name2 << ":- ";
                     cipher_Info2( algo_name2);
                 }
                 if(!algo_name3.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name3 << ":- ";
                     cipher_Info3( algo_name3);
                 }
                 if(!algo_name4.empty() && algo_name1.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name4 << ":- ";
                     cipher_Info1( algo_name1);
                 }
                 if(!algo_name5.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name5 << ":- ";
                 }
                 if(!algo_name6.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name6 << ":- ";
                     cipher_Info6( algo_name6);
                 }
                 if(algo_name6.empty() && !algo_name2.empty() && (!algo_name1.empty() || !algo_name4.empty()))
                 {
                    // counter+=1;
                    std::cout << "\n\  A SUGGESTION " << endl <<endl;
                     cout << "  " <<  "  * Authenticated Encryption" << ":- Since your security requirements include confidentiality and/or privacy\n";
                     std::cout << "      as well as integrity, you may consider returning to the main menu to select option 10 in order \n";
                     std::cout << "      to modify your request by including 'Confidentiality & Authenticity' in your security require-\n";
                     std::cout << "      ments. This is because the mechanism that provides 'Confidentiality & Authenticity' is the \n";
                     std::cout << "      authenticated encryption, which can provide message integrity and message origin authentication \n";
                     std::cout << "      in addition to protecting data confidentiality and/or user privacy. \n";
                 }
                   counter = 0;


                std::cout << "\n\n  THE OTHER USER SECURITY REQUIREMENTS "  << endl << endl;
                 int counter2 = 0;
                 if(!Re_6.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Availability:- " << "Refers to the property which ensures that an IoT device or system is accessible\n";
                     std::cout << "     and usable upon demand by authorized entities. One way to ensure availability of IoT systems is\n";
                     std::cout << "     to ensure that the systems run efficiently for a long time without breaking down, such as prev-\n";
                     std::cout << "     enting power outages. This often relies on routine maintenance of the devices and network, which\n";
                     std::cout << "     includes regular updates, upgrades, and keeping the systems working reliably. Investing in cloud \n";
                     std::cout << "     services for backup also ensures data availability.\n" << endl;
                 }
                 if(!Re_7.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Physical Security:- " << "Refers to the security measures designed to deny unauthorized physical access \n";
                     std::cout << "     to IoT devices or systems, and to protect them from damage or tampering. Where possible, the first\n";
                     std::cout << "     step in providing physical security is to prevent unauthorized persons from having physical access\n";
                     std::cout << "     to IoT systems. Another line of defense is to make the device casing extremely difficult to open, \n";
                     std::cout << "     and if forcefully opened by a curious attacker, the device should be rendered permanently disabled.\n";
                     std::cout << "     An important option is to remove every physical, radio, or optical ports that were installed for\n";
                     std::cout << "     development purposes. Similarly, every unnecessary test point, such as pins and circuit tracks,  \n";
                     std::cout << "     should be removed or disabled.\n" << endl;
                 }
                 if(!Re_8.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Authorization:- " << "Authorization is usually coupled with authentication, it refers to the property \n";
                     std::cout << "     that determines whether a user or device has rights/privileges to access a resource, or to issue\n";
                     std::cout << "     commands. While access control mechanisms are necessary and crucial for authorization in the IoT,\n";
                     std::cout << "     there are no standardized open-source access control schemes for resource-constrained IoT devices.\n" << endl;
                 }
                 if(!Re_9.empty())
                 {

                       counter2+=1;
                        cout << "  " << counter2 << ". " << "Forgery Resistance:-" << "This is the propriety that ensures that the data shared between entities can-  \n";
                        std::cout << "     not be forged by a third party trying to damage or harm the system or its users. Digital signature  \n";
                        std::cout << "     can provide forgery resistance, however, resource-constrained devices in the IoT may not be able to \n";
                        std::cout << "     handle the computational overhead associated with digital signature due to the large real numbers \n";
                        std::cout << "     required for the signature and the verification processes. Although many researchers have proposed  \n";
                        std::cout << "     lightweight digital signature schemes, implementing digital signature on resource-constrained dev-  \n";
                        std::cout << "     ices is still a challenge. Another option is to use two-factor authentication, which provides a \n";
                        std::cout << "     two-layer protection against unauthorized access.\n" << endl;
                 }
                 if(!Re_10.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Confinement:-" << "Ensures that even if a device is attacked or corrupted, the effects of the attack is\n";
                     std::cout << "     contained or confined only to the device. One way to limit the extent of damage resulting from an \n";
                     std::cout << "     attack on IoT systems is to isolate IoT devices on a separate virtual LAN. This setup will prevent \n";
                     std::cout << "     an attacker from monitoring the totality of network traffic, or launching attacks across the entire \n";
                     std::cout << "     enterprise if one IoT device is compromised. The bottom line is this: you should not connect IoT  \n";
                     std::cout << "     devices on the same network with mission-critical systems.\n" << endl;
                 }
                 if(!Re_11.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Accountability:-" << "This is the property that ensures that every action can be traced back to a single\n";
                     std::cout << "     user or device. While Blockchain technology and emerging data provenance methods that track and  \n";
                     std::cout << "     record the flow of data end-to-end between components hold real promise, accountability in the IoT  \n";
                     std::cout << "     is still a major challenge. For more details on this subject, see \n";
                     std::cout << "     https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8423131.\n" << endl;
                 }
                 if(!Re_12.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Reliability:-" << "Is the property that guarantees consistent intended behavior of an IoT system. A sys-\n";
                     std::cout << "     tematic approach to design that can help to ensure reliable IoT systems will entail incorporating\n";
                     std::cout << "     some form of error or fault detection mechanisms. Such mechanisms can, if possible, correct the \n";
                     std::cout << "     corruption or fault, or isolate the source of the error and report it to a recovery mechanism that\n";
                     std::cout << "     can switch to a redundant replacement component or system. Regular testing, backing up, disaster\n";
                     std::cout << "     recovery plans, and redundancy will help to improve the reliability of an IoT system.\n" << endl;
                 }
                 if(!Re_13.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Data Freshness:-" << "Ensures that data is the most recent, and that old messages cannot be replayed. \n";
                     std::cout << "     Data freshness is a critical requirement in the IoT, especially for critical automated decision-\n";
                     std::cout << "     making processes (for example, in the smart healthcare and self-driving cars scenarios) where every \n";
                     std::cout << "     millisecond counts. Nonetheless, ensuring data freshness in the IoT is still an active research \n";
                     std::cout << "     topic. However, the ZigBee wireless technology that operates on top of the IEEE 802.15.4 standard  \n";
                     std::cout << "     provides data freshness in addition to authentication, message integrity, and encryption.\n" << endl;
                 }
                 if(!Re_14.empty())
                 {
                        counter2+=1;
                        cout << "  " << counter2 << ". " << "Counterfeit Resistance:-" << "Is the property that ensures effective validation of software such that any\n";
                        std::cout << "     fake or maliciously modified software is rejected. Software counterfeiting can be prevented by pro-\n";
                        std::cout << "     viding a means by which software can be validated. This is to ensure that third-party software with \n";
                        std::cout << "     hidden vulnerabilities, as well as fake and maliciously modified software is detected and rejected. \n" << endl;
                 }
                 if(!Re_15.empty())
                 {
                     counter2+=1;
                     cout << "  " << counter2 << ". " << "Tamper Detection:-" << "Ensures that every active attempt to compromise the integrity of an IoT system\n";
                     std::cout << "     or the data associated with an IoT system is detected. The tamper detection design can be implem- \n";
                     std::cout << "     ented using a suite of sensors, each designed to sense a particular physical penetration type. \n";
                     std::cout << "     Other parameters that could be sensed include input voltage variations, input frequency variations,\n";
                     std::cout << "     gamma rays, and x-rays. The detection of a threat may enable the device to initiate appropriate de- \n";
                     std::cout << "     fensive actions, which may ultimately result in the deletion of any useful data." << endl;
                 }
                   counter = 0;
        }
        else if(flag == 2)
        {
                std::cout << endl << endl;
                std::cout << "\n\t A DETAILED REPORT ON THE RESULTS OF THE REQUEST OF USER WITH REQUEST ID No.: " << request_id <<endl <<endl;
                std::cout << "   This report consists of brief information about the recommended Lightweight Cryptographic Algorithms,\n";
                std::cout << "   and where applicable, it provides information on where to find the algorithms.\n";

                std::cout << endl;

                std::cout << "\n\  THE RECOMMENDED ALGORITHMS " << endl <<endl;

                int counter = 0;
                 if(!algo_name1.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name1 << ":- ";
                     cipher_Info1( algo_name1);
                 }
                 if(!algo_name2.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name2 << ":- ";
                     cipher_Info2( algo_name2);
                 }
                 if(!algo_name3.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name3 << ":- ";
                     cipher_Info3( algo_name3);
                 }
                 if(!algo_name4.empty() && algo_name1.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name4 << ":- ";
                     cipher_Info1( algo_name1);
                 }
                 if(!algo_name5.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name5 << ":- ";
                 }
                 if(!algo_name6.empty())
                 {
                     counter+=1;
                     cout << "  " << counter << ". " << algo_name6 << ":- ";
                     cipher_Info6( algo_name6);
                 }
                 if(algo_name6.empty() && !algo_name2.empty() && (!algo_name1.empty() || !algo_name4.empty()))
                 {
                     std::cout << "\n\  A SUGGESTION " << endl <<endl;
                     cout << "  " <<  "  * Authenticated Encryption" << ":- Since your security requirements include confidentiality and/or privacy\n";
                     std::cout << "      as well as integrity, you may consider returning to the main menu to select option 10 in order \n";
                     std::cout << "      to modify your request by including 'Confidentiality & Authenticity' in your security require-\n";
                     std::cout << "      ments. This is because the mechanism that provides 'Confidentiality & Authenticity' is the \n";
                     std::cout << "      authenticated encryption, which can provide message integrity and message origin authentication \n";
                     std::cout << "      in addition to protecting data confidentiality and/or user privacy. \n";
                 }
                   counter = 0;
            }
}

void Report::formatReport_for_TextFile(string request_id, int flag, string algo_name1, string algo_name2, string algo_name3, string algo_name4, string algo_name5, string algo_name6, string Re_6, string Re_7, string Re_8, string Re_9, string Re_10, string Re_11, string Re_12, string Re_13, string Re_14, string Re_15)
{
            fstream file;
            file.open("Detail_Result.txt", ios::out | ios::trunc);
            if(file.is_open())
            {
                if(flag == 1)
                {
                        file << endl << endl;
                        //file << "\n" "*****************************************************************************************************************" << endl;
                        file << "\n\t A DETAILED REPORT ON THE RESULTS OF THE REQUEST OF USER WITH REQUEST ID No.: " << request_id << endl <<endl;
                        file << "   This report consists of brief information about the recommended Lightweight Cryptographic Algorithms,\n";
                        file << "   and where applicable, it provides information on where to find the algorithms. The report also includes\n";
                        file << "   some security measures needed to be taken in order to meet the remaining security requirements\n";
                        file << "   that were generated by the security Requirement Elicitation tool to which no security mechanisms and \n";
                        file << "   algorithms have been recommended.\n";

                        file << endl;

                        file << "\n\  THE RECOMMENDED ALGORITHMS " << endl <<endl;

                        int counter = 0;


                         if(!algo_name1.empty())
                         {
                            std::string option1 = "SPECK", option2 = "SIMON", option3 = "Clefi", option4 = "Midor", option5 = "TWINE", option6 = "Picco", option7 = "ChaCh", option8 = "Enoco", option9 = "Grain", option10 = "Trivi", option11 = "MICKE";
                            std::string algoName = algo_name1.substr(0, 5);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name1 << ":- ";

								if(algoName == option1)
                                {
                                    file << "SPECK is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SPECK has been optimized for performance in software \n";
                                    file << "     implementation. SPECK supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SPECK can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "SIMON is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SIMON has been optimized for performance in hardware \n";
                                    file << "     implementation. SIMON supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SIMON can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "CLEFIA is a lightweight proprietary block cipher algorithm developed by Sony. The \n";
                                    file << "     block cipher is intended to serve as a safe alternative to AES with the flexibility for efficient\n";
                                    file << "     implementation in both hardware and software. CLEFIA supports 128-bit (16 bytes) block size and \n";
                                    file << "     three different key sizes of 128, 192, and 256 bits. More information about CLEFIA can be found at\n";
                                    file << "     https://www.sony.net/Products/cryptography/clefia/about/appendix_01.html, and a C implementation  \n";
                                    file << "     can be found at https://github.com/fedescarpa/clefia. \n" << endl;
                                }
                                else if(algoName == option4)
                                {
                                    file << "Midori, a Japanese word for green, is a 128-bit secret key block cipher that comes \n";
                                    file << "     in two variants, Midori 64 and Midori 128. The 64 and 128 correspond to the different block sizes\n";
                                    file << "     (i.e., Midori 64/128 and Midori 128/128). The two variants of Midori provide acceptable security \n";
                                    file << "     level with optimal energy consumption when implemented in hardware. More information about Midori \n";
                                    file << "     can be found at https://eprint.iacr.org/2015/1142.pdf, and a hardware design of Midori 128 written \n";
                                    file << "     in VHDL can be found at https://github.com/tomirio619/Midori. \n" << endl;
                                }
                                else if(algoName == option5)
                                {
                                    file << "TWINE is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes. The\n";
                                    file << "     cipher is designed to be efficient on both software and hardware. For software implementation, TWINE\n";
                                    file << "     consumes less CPU time and occupies a small ROM space. The cipher is also designed to perform well\n";
                                    file << "     on various types of CPUs, from low-end microcontrollers to high-end CPUs, such as the Intel Core-i\n";
                                    file << "     series. For more information on TWINE, refer to https://wwwljk.imag.fr/membres/Pierre.Karpman/cry_\n";
                                    file << "     intro_tp_twine.pdf. In addition, some information on the C implementation of TWINE can be found at \n";
                                    file << "     https://github.com/dgryski/go-twine.\n" << endl;
                                }
                                else if(algoName == option6)
                                {
                                    file<< "Piccolo is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes.\n";
                                    file << "     The cipher achieves both high security and notably compact implementation in hardware. For example, \n";
                                    file << "     for encryption, the gate equivalent (GE) requirements for the 80 and the 128-bit key modes are only\n";
                                    file << "     683 and 758, respectively; and only 60 additional GEs are required to support the decryption function.\n";
                                    file << "     More information about the structure of Piccolo can be found at https://www.iacr.org/archive/ches2011\n";
                                    file << "     /69170343/69170343.pdf, and a C implementation can be found at https://github.com/Daeinar/piccolo.\n"<< endl;

                                }
                                else if(algoName == option7)
                                {
                                    file << "ChaCha20 is a stream cipher with a 256-bit key and a 96-bit initialization vector(IV).\n";
                                    file << "     Aside from a secret key and an IV, it receives a 128-bit constant anda 32-bit block counter, and \n";
                                    file << "     outputs a 512-bit pseudo-random number. The algorithm utilizes 32-bit word arithmetic additions, \n";
                                    file << "     exclusive ORs (XORs), and cyclic shifts, and is suitable for software implementation. Because it  \n";
                                    file << "     requires little cost for initialization, it can process short messages quickly. Additionally, \n";
                                    file << "     ChaCha20 uses no table lookups, straightforward implementation is secure against cache-timing \n";
                                    file << "     attacks. More information about the stream cipher can be found at https://asecuritysite.com/\n";
                                    file << "     encryption/chacha, and https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf; and a C \n";
                                    file << "     implementation can be found at https://github.com/Ginurx/chacha20-c\n"<< endl;
                                }
                                else if(algoName == option8)
                                {
                                    file << "Enocoro is a stream cipher that consists of two algorithms, Enocoro-80 with 80-bit key \n";
                                    file << "     and Enocoro-128v2 with 128-bit key. The two algorithms claim a level of security corresponding to the \n";
                                    file << "     key length. But the output data is limited to 2^32 bytes and 2^64 bytes, respectively, by fixing the \n";
                                    file << "     key and IV. Unlike other lightweight stream ciphers, this cipher processes in 8-bit units and can \n";
                                    file << "     achieve  processing speeds similar to AES even in software implementation. More information and code\n";
                                    file << "     can be found at https://www.hitachi.com/rd/yrl/crypto/enocoro/index.html. Additional information can \n";
                                    file << "     also be found at https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;

                                }
                                else if(algoName == option9)
                                {
                                    file << "Grain is a hardware-oritented stream cipher. Two algorithms of Grain were selected for\n";
                                    file << "     the eSTREAM portfolio: one with an 80-bit key and a 64-bit IV and the other with a 128-bit key and\n";
                                    file << "     an 80-bit IV. The cipher comprises one bitwise linear feedback shift register and one non-linear\n";
                                    file << "     feedback shift register. Among other lightweight stream ciphers, this stream cipher is superior for \n";
                                    file << "     lightweight hardware implementation. It can achieve certain degrees of parallelism, software \n";
                                    file << "     implementation performs sufficiently for practical uses. For more information on the cipher, we \n";
                                    file << "     refer the user to https://cr.yp.to/streamciphers/grain/desc.pdf, and  https://www.cryptrec.go.jp/\n";
                                    file << "     report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;
                                }
                                else if(algoName == option10)
                                {
                                    file << "Trivium is a stream cipher that is optimized for hardware implementation, which was  \n";
                                    file << "     selected in the eSTREAM portfolio. The cipher accepts an 80-bit key and an 80-bit IV. A keystream \n";
                                    file << "     generated for each pair of key and IV is limited to 264 bits. Trivium has a unique design consisting  \n";
                                    file << "     of three serial non-linear feedback shift registers of different lengths. Based on bitwise operations,\n";
                                    file << "     but having high levels of parallelism, it features lightweight hardware implementation and high \n";
                                    file << "     speeds in software implementation. Nonetheless, Trivium is not suitable for processing short data \n";
                                    file << "     because of its long initialization time. More information can be found at https://eprint.iacr.org/\n";
                                    file << "     2009/431.pdf and  https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. A VHDL \n";
                                    file << "     implementation of Trivium can be found at https://github.com/akshjums/Trivium-Cipher.\n" << endl;
                                }
                                else if(algoName == option11)
                                {
                                    file << "MICKEY 2.0 is a hardware-oriented stream cipher selected in the eSTREAM portfolio. The \n";
                                    file << "     cipher accepts an 80-bit key and an 80-bit IV. The number of available IVs for a fixed key is limited \n";
                                    file << "     up to 240. In addition, the maximum length of a keystream for a pair of key and IV is 240 bits. This  \n";
                                    file << "     stream cipher consists of one linear feedback shift register and one non-linear feedback shift \n";
                                    file << "     register, featuring irregular clock control. Parallel processing is difficult due to the clock \n";
                                    file << "     control mechanism. More information can be found at http://www.ecrypt.eu.org/stream/mickeypf.html.\n";
                                    file << "     \n";
                                    file << "      \n";
                                    file << "     \n" << endl;
                                }

                         }
                         if(!algo_name2.empty())
                         {
                             std::string option1 = "PHOTON", option2 = "SPONGE", option3 = "Keccak", option4 = "U-QUAR", option5 = "S-QUAR";
                             std::string algoName = algo_name2.substr(0, 6);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name2 << ":- ";

                               if(algoName == option1)
                                {
                                    file << "PHOTON is a family of lightweight hash functions that come in five different \n";
                                    file << "     flavors with the following digest sizes: 80, 128, 160, 224 and 256 bits. PHOTON can be represented \n";
                                    file << "     in this format: PHOTON-n/r/r', where n is the output length in bits, r represents the input block  \n";
                                    file << "     length, and r' is the output block length. Thus, the five variants are PHOTON-80/20/16, PHOTON-128  \n";
                                    file << "     /16/16, PHOTON-160/36/36, PHOTON-224/32/32, and PHOTON-256/32/32. The lightweight hash function is \n";
                                    file << "     suitable for extremely constrained devices such as passive RFID tags. Although it is optimized for \n";
                                    file << "     hardware implementation, PHOTON can equally be implemented in software. More details about PHOTON \n";
                                    file << "     can be found at https://eprint.iacr.org/2011/609.pdf and https://pdfs.semanticscholar.org/63d1/ \n";
                                    file << "     7f64d7a7d5b1bcd199c2569334e7194e40e1.pdf.\n"<< endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "SPONGENT a family of lightweight hash functions based on a sponge construction   \n";
                                    file << "     instantiated with a PRESENT-type permutation. SPONGENT can produce hash sizes of 88, 128, 160, 224,\n";
                                    file << "     and 256 bit. It offers a lot of flexibility in terms of serialization degree and speed. For more\n";
                                    file << "     information about SPONGENT, refer to https://www.iacr.org/archive/ches2011/69170311/69170311.pdf\n"<< endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "Keccak is a set of seven permutation functions called Keccak-f[b], which can be \n";
                                    file << "     used to construct a stream cipher, a cryptographic hash function, a Pseudo Random Number Generator \n";
                                    file << "     (PRNG), Message Authentication Code (MAC) or an Authenticated Encryption Associated Data (AEAD)  \n";
                                    file << "     algorithm. The 'b' represents the width which is between 25 and 1600 by multiplicative steps of 2\n";
                                    file << "     (b 25, 50, 100, 200, 400, 800, 1,600). The functions relevant to the lightweight cryptography are  \n";
                                    file << "     Keccak-f[100], Keccak-f[200], and Keccak-f[400]. More information about Keccak can be found at \n";
                                    file << "     https://keccak.team/ and https://www.iacr.org/archive/eurocrypt2013/78810311/78810311.pdf.  \n" << endl;
                                }
                                else if(algoName == option4)
                                {
                                    file << "QUARK is a hash function family consisting of three instances, namely U-QUARK,  \n";
                                    file << "     D-QUARK, and S-QUARK. It can be used for message authentication, stream encryption, or  \n";
                                    file << "     authenticated encryption. QUARK is based on a sponge construction, and it is only optimized \n";
                                    file << "     for hardware implementation. More details about the lightweight hash function can be found\n";
                                    file << "     at https://131002.net/quark/quark_full.pdf, and https://www.iacr.org/archive/ches2010/62250001 \n";
                                    file << "     /62250001.pdf; and a C implementation can be found at https://github.com/veorq/Quark. \n" << endl;
                                }
                                else if(algoName == option5)
                                {
                                    file << "QUARK is a hash function family consisting of three instances, namely U-QUARK,  \n";
                                    file << "     D-QUARK, and S-QUARK. It can be used for message authentication, stream encryption, or  \n";
                                    file << "     authenticated encryption. QUARK is based on a sponge construction, and it is only optimized \n";
                                    file << "     for hardware implementation. More details about the lightweight hash function can be found\n";
                                    file << "     at https://131002.net/quark/quark_full.pdf, and https://www.iacr.org/archive/ches2010/62250001 \n";
                                    file << "     /62250001.pdf; and a C implementation can be found at https://github.com/veorq/Quark. \n" << endl;
                                }
                         }
                         if(!algo_name3.empty())
                         {
                             std::string option1 = "SipHas", option2 = "", option3 = "";
                             std::string algoName = algo_name3.substr(0, 6);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name3 << ":- ";

                                if(algoName == option1)
                                {
                                    file << "SipHash is a keyed hash function with a key length of 128 bits and an output length\n";
                                    file << "     of 64 bits. It is optimized for software implementation and runs fast on a CPU that supports \n";
                                    file << "     64-bit operations only. The target applications of SipHash include network traffic authentication \n";
                                    file << "     and hash-table lookups protected against hash-flooding denial-of-service attacks. More information \n";
                                    file << "     about the SipHash can be found at https://cr.yp.to/siphash/siphash-20120620.pdf, and a Javascript  \n";
                                    file << "     implementation can be found at https://github.com/jedisct1/siphash-js.  \n" << endl;
                                }
                                else if(algoName == option2)
                                {

                                }
                                else if(algoName == option3)
                                {

                                }
                         }
                         if(!algo_name4.empty() && algo_name1.empty())
                         {
                             std::string option1 = "SPECK", option2 = "SIMON", option3 = "Clefi", option4 = "Midor", option5 = "TWINE", option6 = "Picco", option7 = "ChaCh", option8 = "Enoco", option9 = "Grain", option10 = "Trivi", option11 = "MICKE";
                             std::string algoName = algo_name1.substr(0, 5);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name4 << ":- ";

                             if(algoName == option1)
                                {
                                    file << "SPECK is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SPECK has been optimized for performance in software \n";
                                    file << "     implementation. SPECK supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SPECK can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "SIMON is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SIMON has been optimized for performance in hardware \n";
                                    file << "     implementation. SIMON supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SIMON can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "CLEFIA is a lightweight proprietary block cipher algorithm developed by Sony. The \n";
                                    file << "     block cipher is intended to serve as a safe alternative to AES with the flexibility for efficient\n";
                                    file << "     implementation in both hardware and software. CLEFIA supports 128-bit (16 bytes) block size and \n";
                                    file << "     three different key sizes of 128, 192, and 256 bits. More information about CLEFIA can be found at\n";
                                    file << "     https://www.sony.net/Products/cryptography/clefia/about/appendix_01.html, and a C implementation  \n";
                                    file << "     can be found at https://github.com/fedescarpa/clefia. \n" << endl;
                                }
                                else if(algoName == option4)
                                {
                                    file << "Midori, a Japanese word for green, is a 128-bit secret key block cipher that comes \n";
                                    file << "     in two variants, Midori 64 and Midori 128. The 64 and 128 correspond to the different block sizes\n";
                                    file << "     (i.e., Midori 64/128 and Midori 128/128). The two variants of Midori provide acceptable security \n";
                                    file << "     level with optimal energy consumption when implemented in hardware. More information about Midori \n";
                                    file << "     can be found at https://eprint.iacr.org/2015/1142.pdf, and a hardware design of Midori 128 written \n";
                                    file << "     in VHDL can be found at https://github.com/tomirio619/Midori. \n" << endl;
                                }
                                else if(algoName == option5)
                                {
                                    file << "TWINE is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes. The\n";
                                    file << "     cipher is designed to be efficient on both software and hardware. For software implementation, TWINE\n";
                                    file << "     consumes less CPU time and occupies a small ROM space. The cipher is also designed to perform well\n";
                                    file << "     on various types of CPUs, from low-end microcontrollers to high-end CPUs, such as the Intel Core-i\n";
                                    file << "     series. For more information on TWINE, refer to https://wwwljk.imag.fr/membres/Pierre.Karpman/cry_\n";
                                    file << "     intro_tp_twine.pdf. In addition, some information on the C implementation of TWINE can be found at \n";
                                    file << "     https://github.com/dgryski/go-twine.\n" << endl;
                                }
                                else if(algoName == option6)
                                {
                                    file<< "Piccolo is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes.\n";
                                    file << "     The cipher achieves both high security and notably compact implementation in hardware. For example, \n";
                                    file << "     for encryption, the gate equivalent (GE) requirements for the 80 and the 128-bit key modes are only\n";
                                    file << "     683 and 758, respectively; and only 60 additional GEs are required to support the decryption function.\n";
                                    file << "     More information about the structure of Piccolo can be found at https://www.iacr.org/archive/ches2011\n";
                                    file << "     /69170343/69170343.pdf, and a C implementation can be found at https://github.com/Daeinar/piccolo.\n"<< endl;

                                }
                                else if(algoName == option7)
                                {
                                    file << "ChaCha20 is a stream cipher with a 256-bit key and a 96-bit initialization vector(IV).\n";
                                    file << "     Aside from a secret key and an IV, it receives a 128-bit constant anda 32-bit block counter, and \n";
                                    file << "     outputs a 512-bit pseudo-random number. The algorithm utilizes 32-bit word arithmetic additions, \n";
                                    file << "     exclusive ORs (XORs), and cyclic shifts, and is suitable for software implementation. Because it  \n";
                                    file << "     requires little cost for initialization, it can process short messages quickly. Additionally, \n";
                                    file << "     ChaCha20 uses no table lookups, straightforward implementation is secure against cache-timing \n";
                                    file << "     attacks. More information about the stream cipher can be found at https://asecuritysite.com/\n";
                                    file << "     encryption/chacha, and https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf; and a C \n";
                                    file << "     implementation can be found at https://github.com/Ginurx/chacha20-c\n"<< endl;
                                }
                                else if(algoName == option8)
                                {
                                    file << "Enocoro is a stream cipher that consists of two algorithms, Enocoro-80 with 80-bit key \n";
                                    file << "     and Enocoro-128v2 with 128-bit key. The two algorithms claim a level of security corresponding to the \n";
                                    file << "     key length. But the output data is limited to 2^32 bytes and 2^64 bytes, respectively, by fixing the \n";
                                    file << "     key and IV. Unlike other lightweight stream ciphers, this cipher processes in 8-bit units and can \n";
                                    file << "     achieve  processing speeds similar to AES even in software implementation. More information and code\n";
                                    file << "     can be found at https://www.hitachi.com/rd/yrl/crypto/enocoro/index.html. Additional information can \n";
                                    file << "     also be found at https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;

                                }
                                else if(algoName == option9)
                                {
                                    file << "Grain is a hardware-oritented stream cipher. Two algorithms of Grain were selected for\n";
                                    file << "     the eSTREAM portfolio: one with an 80-bit key and a 64-bit IV and the other with a 128-bit key and\n";
                                    file << "     an 80-bit IV. The cipher comprises one bitwise linear feedback shift register and one non-linear\n";
                                    file << "     feedback shift register. Among other lightweight stream ciphers, this stream cipher is superior for \n";
                                    file << "     lightweight hardware implementation. It can achieve certain degrees of parallelism, software \n";
                                    file << "     implementation performs sufficiently for practical uses. For more information on the cipher, we \n";
                                    file << "     refer the user to https://cr.yp.to/streamciphers/grain/desc.pdf, and  https://www.cryptrec.go.jp/\n";
                                    file << "     report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;
                                }
                                else if(algoName == option10)
                                {
                                    file << "Trivium is a stream cipher that is optimized for hardware implementation, which was  \n";
                                    file << "     selected in the eSTREAM portfolio. The cipher accepts an 80-bit key and an 80-bit IV. A keystream \n";
                                    file << "     generated for each pair of key and IV is limited to 264 bits. Trivium has a unique design consisting  \n";
                                    file << "     of three serial non-linear feedback shift registers of different lengths. Based on bitwise operations,\n";
                                    file << "     but having high levels of parallelism, it features lightweight hardware implementation and high \n";
                                    file << "     speeds in software implementation. Nonetheless, Trivium is not suitable for processing short data \n";
                                    file << "     because of its long initialization time. More information can be found at https://eprint.iacr.org/\n";
                                    file << "     2009/431.pdf and  https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. A VHDL \n";
                                    file << "     implementation of Trivium can be found at https://github.com/akshjums/Trivium-Cipher.\n" << endl;
                                }
                                else if(algoName == option11)
                                {
                                    file << "MICKEY 2.0 is a hardware-oriented stream cipher selected in the eSTREAM portfolio. The \n";
                                    file << "     cipher accepts an 80-bit key and an 80-bit IV. The number of available IVs for a fixed key is limited \n";
                                    file << "     up to 240. In addition, the maximum length of a keystream for a pair of key and IV is 240 bits. This  \n";
                                    file << "     stream cipher consists of one linear feedback shift register and one non-linear feedback shift \n";
                                    file << "     register, featuring irregular clock control. Parallel processing is difficult due to the clock \n";
                                    file << "     control mechanism. More information can be found at http://www.ecrypt.eu.org/stream/mickeypf.html.\n";
                                    file << "     \n";
                                    file << "      \n";
                                    file << "     \n" << endl;
                                }
                         }
                         if(!algo_name5.empty())
                         {
                             counter+=1;
                             file << "  " << counter << ". " << algo_name5 << ":- ";
                         }
                         if(!algo_name6.empty())
                         {
                             std::string option1 = "ACORN", option2 = "Ascon", option3 = "CLOC-";
                             std::string algoName = algo_name6.substr(0, 5);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name6 << ":- ";
                              if(algoName == option1)
                                {
                                    file << "ACORN is a stream cipher based authenticated encryption with associated data (AEAD) algorithm.\n";
                                    file << "     It is a 128-bit key and a 128-bit initialization vector (IV) cipher that produces a 128-bit\n";
                                    file << "     authentication tag. While ACORN is a hardware-oriented stream cipher, the version three (ACORN v3),\n";
                                    file << "     which processes one bit per step,  is a bit-based sequential authenticated cipher that is very fast \n";
                                    file << "     in both hardware and software as up to 32 steps can be processed in parallel. More information about \n";
                                    file << "     the cipher can be found at https://competitions.cr.yp.to/round1/acornv1.pdf and  \n";
                                    file << "     https://eprint.iacr.org/2014/157.pdf.\n" << endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "Ascon is a family of authenticated encryption and hashing algorithms that has been selected\n";
                                    file << "     as the primary choice for lightweight authenticated encryption in the final portfolio of the CAESAR \n";
                                    file << "     competition (2014–2019). The cipher is also currently competing in the NIST Lightweight Cryptography\n";
                                    file << "     competition (2019–). Ascon is designed to be lightweight, easy to implement, and is very fast in both\n";
                                    file << "     hardware and software as up to 32 steps can be processed in parallel, even with added countermeasures \n";
                                    file << "     against side-channel attacks. The recommended key, tag and nonce length for Ascon is 128 bits. More \n";
                                    file << "     information about Ascon can be found at https://ascon.iaik.tugraz.at/ and https://competitions.cr.yp\n";
                                    file << "     .to/round3/asconv12.pdf. \n" << endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "CLOC, which is pronounced as 'clock', stands for Compact Low-Overhead CFB. It is a\n";
                                    file << "     lightweight authenticated encryption algorithm designed to achieve low overhead computation. \n";
                                    file << "     Although CLOC is designed to handle short input data like 16 bytes, its sequential nature and its \n";
                                    file << "     asymptotic performance for long input data makes it comparable to CCM, EAX and EAX-prime. CLOC uses \n";
                                    file << "     AES for 128-bit block cipher; it is as well defined with a 64-bit block cipher TWINE. More informa-  \n";
                                    file << "     tion about CLOC can be found at http://www.nuee.nagoya-u.ac.jp/labs/tiwata/AE/, and  \n";
                                    file << "     https://eprint.iacr.org/2014/157.pdf.\n" << endl;
                                }
                         }
                         if(algo_name6.empty() && !algo_name2.empty() && (!algo_name1.empty() || !algo_name4.empty()))
                         {
                             file << "\n\  A SUGGESTION " << endl <<endl;
                             file << "  " <<  "  * Authenticated Encryption" << ":- Since your security requirements include confidentiality and/or privacy\n";
                             file << "      as well as integrity, you may consider returning to the main menu to select option 10 in order \n";
                             file << "      to modify your request by including 'Confidentiality & Authenticity' in your security require-\n";
                             file << "      ments. This is because the mechanism that provides 'Confidentiality & Authenticity' is the \n";
                             file << "      authenticated encryption, which can provide message integrity and message origin authentication \n";
                             file << "      in addition to protecting data confidentiality and/or user privacy. \n";
                         }
                           counter = 0;


                           file << "\n\n  THE OTHER USER SECURITY REQUIREMENTS "  << endl << endl;
                             int counter2 = 0;
                             if(!Re_6.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Availability:- " << "Refers to the property which ensures that an IoT device or system is accessible\n";
                                 file << "     and usable upon demand by authorized entities. One way to ensure availability of IoT systems is\n";
                                 file << "     to ensure that the systems run efficiently for a long time without breaking down, such as prev-\n";
                                 file << "     enting power outages. This often relies on routine maintenance of the devices and network, which\n";
                                 file << "     includes regular updates, upgrades, and keeping the systems working reliably. Investing in cloud \n";
                                 file << "     services for backup also ensures data availability.\n" << endl;
                             }
                             if(!Re_7.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Physical Security:- " << "Refers to the security measures designed to deny unauthorized physical access \n";
                                 file << "     to IoT devices or systems, and to protect them from damage or tampering. Where possible, the first\n";
                                 file << "     step in providing physical security is to prevent unauthorized persons from having physical access\n";
                                 file << "     to IoT systems. Another line of defense is to make the device casing extremely difficult to open, \n";
                                 file << "     and if forcefully opened by a curious attacker, the device should be rendered permanently disabled.\n";
                                 file << "     An important option is to remove every physical, radio, or optical ports that were installed for\n";
                                 file << "     development purposes. Similarly, every unnecessary test point, such as pins and circuit tracks,  \n";
                                 file << "     should be removed or disabled.\n" << endl;
                             }
                             if(!Re_8.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Authorization:- " << "Authorization is usually coupled with authentication, it refers to the property \n";
                                 file << "     that determines whether a user or device has rights/privileges to access a resource, or to issue\n";
                                 file << "     commands. While access control mechanisms are necessary and crucial for authorization in the IoT,\n";
                                 file << "     there are no standardized open-source access control schemes for resource-constrained IoT devices.\n" << endl;
                             }
                             if(!Re_9.empty())
                             {
                                   counter2+=1;
                                    file << "  " << counter2 << ". " << "Forgery Resistance:-" << "This is the propriety that ensures that the data shared between entities can-  \n";
                                    file << "     not be forged by a third party trying to damage or harm the system or its users. Digital signature  \n";
                                    file << "     can provide forgery resistance, however, resource-constrained devices in the IoT may not be able to \n";
                                    file << "     handle the computational overhead associated with digital signature due to the large real numbers \n";
                                    file << "     required for the signature and the verification processes. Although many researchers have proposed  \n";
                                    file << "     lightweight digital signature schemes, implementing digital signature on resource-constrained dev-  \n";
                                    file << "     ices is still a challenge. Another option is to use two-factor authentication, which provides a \n";
                                    file << "     two-layer protection against unauthorized access.\n" << endl;
                             }
                             if(!Re_10.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Confinement:-" << "Ensures that even if a device is attacked or corrupted, the effects of the attack is\n";
                                 file << "     contained or confined only to the device. One way to limit the extent of damage resulting from an \n";
                                 file << "     attack on IoT systems is to isolate IoT devices on a separate virtual LAN. This setup will prevent \n";
                                 file << "     an attacker from monitoring the totality of network traffic, or launching attacks across the entire \n";
                                 file << "     enterprise if one IoT device is compromised. The bottom line is this: you should not connect IoT  \n";
                                 file << "     devices on the same network with mission-critical systems.\n" << endl;
                             }
                             if(!Re_11.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Accountability:-" << "This is the property that ensures that every action can be traced back to a single\n";
                                 file << "     user or device. While Blockchain technology and emerging data provenance methods that track and  \n";
                                 file << "     record the flow of data end-to-end between components hold real promise, accountability in the IoT  \n";
                                 file << "     is still a major challenge. For more details on this subject, see \n";
                                 file << "     https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8423131.\n" << endl;
                             }
                             if(!Re_12.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Reliability:-" << "Is the property that guarantees consistent intended behavior of an IoT system. A sys-\n";
                                 file << "     tematic approach to design that can help to ensure reliable IoT systems will entail incorporating\n";
                                 file << "     some form of error or fault detection mechanisms. Such mechanisms can, if possible, correct the \n";
                                 file << "     corruption or fault, or isolate the source of the error and report it to a recovery mechanism that\n";
                                 file << "     can switch to a redundant replacement component or system. Regular testing, backing up, disaster\n";
                                 file << "     recovery plans, and redundancy will help to improve the reliability of an IoT system.\n" << endl;
                             }
                             if(!Re_13.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Data Freshness:-" << "Ensures that data is the most recent, and that old messages cannot be replayed. \n";
                                 file << "     Data freshness is a critical requirement in the IoT, especially for critical automated decision-\n";
                                 file << "     making processes (for example, in the smart healthcare and self-driving cars scenarios) where every \n";
                                 file << "     millisecond counts. Nonetheless, ensuring data freshness in the IoT is still an active research \n";
                                 file << "     topic. However, the ZigBee wireless technology that operates on top of the IEEE 802.15.4 standard  \n";
                                 file << "     provides data freshness in addition to authentication, message integrity, and encryption.\n" << endl;
                             }
                             if(!Re_14.empty())
                             {
                                    counter2+=1;
                                    file << "  " << counter2 << ". " << "Counterfeit Resistance:-" << "Is the property that ensures effective validation of software such that any\n";
                                    file << "     fake or maliciously modified software is rejected. Software counterfeiting can be prevented by pro-\n";
                                    file << "     viding a means by which software can be validated. This is to ensure that third-party software with \n";
                                    file << "     hidden vulnerabilities, as well as fake and maliciously modified software is detected and rejected. \n" << endl;
                             }
                             if(!Re_15.empty())
                             {
                                 counter2+=1;
                                 file << "  " << counter2 << ". " << "Tamper Detection:-" << "Ensures that every active attempt to compromise the integrity of an IoT system\n";
                                 file << "     or the data associated with an IoT system is detected. The tamper detection design can be implem- \n";
                                 file << "     ented using a suite of sensors, each designed to sense a particular physical penetration type. \n";
                                 file << "     Other parameters that could be sensed include input voltage variations, input frequency variations,\n";
                                 file << "     gamma rays, and x-rays. The detection of a threat may enable the device to initiate appropriate de- \n";
                                 file << "     fensive actions, which may ultimately result in the deletion of any useful data." << endl;
                             }
                               counter = 0;
                }
                else if(flag == 2)
                {
                        file << endl << endl;
                        //file << "\n" "*****************************************************************************************************************" << endl;
                        file << "\n\t A DETAILED REPORT ON THE RESULTS OF THE REQUEST OF USER WITH REQUEST ID No.:" << request_id << endl <<endl;
                        file << "   This report consists of brief information about the recommended Lightweight Cryptographic Algorithms,\n";
                        file << "   and where applicable, it provides information on where to find the algorithms.\n";

                        file << endl;

                        file << "\n\  THE RECOMMENDED ALGORITHMS " << endl <<endl;

                        int counter = 0;


                         if(!algo_name1.empty())
                         {
                            std::string option1 = "SPECK", option2 = "SIMON", option3 = "Clefi", option4 = "Midor", option5 = "TWINE", option6 = "Picco", option7 = "ChaCh", option8 = "Enoco", option9 = "Grain", option10 = "Trivi", option11 = "MICKE";
                            std::string algoName = algo_name1.substr(0, 5);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name1 << ":- ";

                                if(algoName == option1)
                                {
                                    file << "SPECK is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SPECK has been optimized for performance in software \n";
                                    file << "     implementation. SPECK supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SPECK can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "SIMON is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SIMON has been optimized for performance in hardware \n";
                                    file << "     implementation. SIMON supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SIMON can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "CLEFIA is a lightweight proprietary block cipher algorithm developed by Sony. The \n";
                                    file << "     block cipher is intended to serve as a safe alternative to AES with the flexibility for efficient\n";
                                    file << "     implementation in both hardware and software. CLEFIA supports 128-bit (16 bytes) block size and \n";
                                    file << "     three different key sizes of 128, 192, and 256 bits. More information about CLEFIA can be found at\n";
                                    file << "     https://www.sony.net/Products/cryptography/clefia/about/appendix_01.html, and a C implementation  \n";
                                    file << "     can be found at https://github.com/fedescarpa/clefia. \n" << endl;
                                }
                                else if(algoName == option4)
                                {
                                    file << "Midori, a Japanese word for green, is a 128-bit secret key block cipher that comes \n";
                                    file << "     in two variants, Midori 64 and Midori 128. The 64 and 128 correspond to the different block sizes\n";
                                    file << "     (i.e., Midori 64/128 and Midori 128/128). The two variants of Midori provide acceptable security \n";
                                    file << "     level with optimal energy consumption when implemented in hardware. More information about Midori \n";
                                    file << "     can be found at https://eprint.iacr.org/2015/1142.pdf, and a hardware design of Midori 128 written \n";
                                    file << "     in VHDL can be found at https://github.com/tomirio619/Midori. \n" << endl;
                                }
                                else if(algoName == option5)
                                {
                                    file << "TWINE is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes. The\n";
                                    file << "     cipher is designed to be efficient on both software and hardware. For software implementation, TWINE\n";
                                    file << "     consumes less CPU time and occupies a small ROM space. The cipher is also designed to perform well\n";
                                    file << "     on various types of CPUs, from low-end microcontrollers to high-end CPUs, such as the Intel Core-i\n";
                                    file << "     series. For more information on TWINE, refer to https://wwwljk.imag.fr/membres/Pierre.Karpman/cry_\n";
                                    file << "     intro_tp_twine.pdf. In addition, some information on the C implementation of TWINE can be found at \n";
                                    file << "     https://github.com/dgryski/go-twine.\n" << endl;
                                }
                                else if(algoName == option6)
                                {
                                    file<< "Piccolo is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes.\n";
                                    file << "     The cipher achieves both high security and notably compact implementation in hardware. For example, \n";
                                    file << "     for encryption, the gate equivalent (GE) requirements for the 80 and the 128-bit key modes are only\n";
                                    file << "     683 and 758, respectively; and only 60 additional GEs are required to support the decryption function.\n";
                                    file << "     More information about the structure of Piccolo can be found at https://www.iacr.org/archive/ches2011\n";
                                    file << "     /69170343/69170343.pdf, and a C implementation can be found at https://github.com/Daeinar/piccolo.\n"<< endl;

                                }
                                else if(algoName == option7)
                                {
                                    file << "ChaCha20 is a stream cipher with a 256-bit key and a 96-bit initialization vector(IV).\n";
                                    file << "     Aside from a secret key and an IV, it receives a 128-bit constant anda 32-bit block counter, and \n";
                                    file << "     outputs a 512-bit pseudo-random number. The algorithm utilizes 32-bit word arithmetic additions, \n";
                                    file << "     exclusive ORs (XORs), and cyclic shifts, and is suitable for software implementation. Because it  \n";
                                    file << "     requires little cost for initialization, it can process short messages quickly. Additionally, \n";
                                    file << "     ChaCha20 uses no table lookups, straightforward implementation is secure against cache-timing \n";
                                    file << "     attacks. More information about the stream cipher can be found at https://asecuritysite.com/\n";
                                    file << "     encryption/chacha, and https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf; and a C \n";
                                    file << "     implementation can be found at https://github.com/Ginurx/chacha20-c\n"<< endl;
                                }
                                else if(algoName == option8)
                                {
                                    file << "Enocoro is a stream cipher that consists of two algorithms, Enocoro-80 with 80-bit key \n";
                                    file << "     and Enocoro-128v2 with 128-bit key. The two algorithms claim a level of security corresponding to the \n";
                                    file << "     key length. But the output data is limited to 2^32 bytes and 2^64 bytes, respectively, by fixing the \n";
                                    file << "     key and IV. Unlike other lightweight stream ciphers, this cipher processes in 8-bit units and can \n";
                                    file << "     achieve  processing speeds similar to AES even in software implementation. More information and code\n";
                                    file << "     can be found at https://www.hitachi.com/rd/yrl/crypto/enocoro/index.html. Additional information can \n";
                                    file << "     also be found at https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;

                                }
                                else if(algoName == option9)
                                {
                                    file << "Grain is a hardware-oritented stream cipher. Two algorithms of Grain were selected for\n";
                                    file << "     the eSTREAM portfolio: one with an 80-bit key and a 64-bit IV and the other with a 128-bit key and\n";
                                    file << "     an 80-bit IV. The cipher comprises one bitwise linear feedback shift register and one non-linear\n";
                                    file << "     feedback shift register. Among other lightweight stream ciphers, this stream cipher is superior for \n";
                                    file << "     lightweight hardware implementation. It can achieve certain degrees of parallelism, software \n";
                                    file << "     implementation performs sufficiently for practical uses. For more information on the cipher, we \n";
                                    file << "     refer the user to https://cr.yp.to/streamciphers/grain/desc.pdf, and  https://www.cryptrec.go.jp/\n";
                                    file << "     report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;
                                }
                                else if(algoName == option10)
                                {
                                    file << "Trivium is a stream cipher that is optimized for hardware implementation, which was  \n";
                                    file << "     selected in the eSTREAM portfolio. The cipher accepts an 80-bit key and an 80-bit IV. A keystream \n";
                                    file << "     generated for each pair of key and IV is limited to 264 bits. Trivium has a unique design consisting  \n";
                                    file << "     of three serial non-linear feedback shift registers of different lengths. Based on bitwise operations,\n";
                                    file << "     but having high levels of parallelism, it features lightweight hardware implementation and high \n";
                                    file << "     speeds in software implementation. Nonetheless, Trivium is not suitable for processing short data \n";
                                    file << "     because of its long initialization time. More information can be found at https://eprint.iacr.org/\n";
                                    file << "     2009/431.pdf and  https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. A VHDL \n";
                                    file << "     implementation of Trivium can be found at https://github.com/akshjums/Trivium-Cipher.\n" << endl;
                                }
                                else if(algoName == option11)
                                {
                                    file << "MICKEY 2.0 is a hardware-oriented stream cipher selected in the eSTREAM portfolio. The \n";
                                    file << "     cipher accepts an 80-bit key and an 80-bit IV. The number of available IVs for a fixed key is limited \n";
                                    file << "     up to 240. In addition, the maximum length of a keystream for a pair of key and IV is 240 bits. This  \n";
                                    file << "     stream cipher consists of one linear feedback shift register and one non-linear feedback shift \n";
                                    file << "     register, featuring irregular clock control. Parallel processing is difficult due to the clock \n";
                                    file << "     control mechanism. More information can be found at http://www.ecrypt.eu.org/stream/mickeypf.html.\n";
                                    file << "     \n";
                                    file << "      \n";
                                    file << "     \n" << endl;
                                }
                         }
                         if(!algo_name2.empty())
                         {
                             std::string option1 = "PHOTON", option2 = "SPONGE", option3 = "Keccak", option4 = "U-QUAR", option5 = "S-QUAR";
                             std::string algoName = algo_name2.substr(0, 6);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name2 << ":- ";

                               if(algoName == option1)
                                {
                                    file << "PHOTON is a family of lightweight hash functions that come in five different \n";
                                    file << "     flavors with the following digest sizes: 80, 128, 160, 224 and 256 bits. PHOTON can be represented \n";
                                    file << "     in this format: PHOTON-n/r/r', where n is the output length in bits, r represents the input block  \n";
                                    file << "     length, and r' is the output block length. Thus, the five variants are PHOTON-80/20/16, PHOTON-128  \n";
                                    file << "     /16/16, PHOTON-160/36/36, PHOTON-224/32/32, and PHOTON-256/32/32. The lightweight hash function is \n";
                                    file << "     suitable for extremely constrained devices such as passive RFID tags. Although it is optimized for \n";
                                    file << "     hardware implementation, PHOTON can equally be implemented in software. More details about PHOTON \n";
                                    file << "     can be found at https://eprint.iacr.org/2011/609.pdf and https://pdfs.semanticscholar.org/63d1/ \n";
                                    file << "     7f64d7a7d5b1bcd199c2569334e7194e40e1.pdf\n"<< endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "SPONGENT a family of lightweight hash functions based on a sponge construction   \n";
                                    file << "     instantiated with a PRESENT-type permutation. SPONGENT can produce hash sizes of 88, 128, 160, 224,\n";
                                    file << "     and 256 bit. It offers a lot of flexibility in terms of serialization degree and speed. For more\n";
                                    file << "     information about SPONGENT, refer to https://www.iacr.org/archive/ches2011/69170311/69170311.pdf\n"<< endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "Keccak is a set of seven permutation functions called Keccak-f[b], which can be \n";
                                    file << "     used to construct a stream cipher, a cryptographic hash function, a Pseudo Random Number Generator \n";
                                    file << "     (PRNG), Message Authentication Code (MAC) or an Authenticated Encryption Associated Data (AEAD)  \n";
                                    file << "     algorithm. The 'b' represents the width which is between 25 and 1600 by multiplicative steps of 2\n";
                                    file << "     (b 25, 50, 100, 200, 400, 800, 1,600). The functions relevant to the lightweight cryptography are  \n";
                                    file << "     Keccak-f[100], Keccak-f[200], and Keccak-f[400]. More information about Keccak can be found at \n";
                                    file << "     https://keccak.team/ and https://www.iacr.org/archive/eurocrypt2013/78810311/78810311.pdf.  \n" << endl;
                                }
                                else if(algoName == option4)
                                {
                                    file << "QUARK is a hash function family consisting of three instances, namely U-QUARK,  \n";
                                    file << "     D-QUARK, and S-QUARK. It can be used for message authentication, stream encryption, or  \n";
                                    file << "     authenticated encryption. QUARK is based on a sponge construction, and it is only optimized \n";
                                    file << "     for hardware implementation. More details about the lightweight hash function can be found\n";
                                    file << "     at https://131002.net/quark/quark_full.pdf, and https://www.iacr.org/archive/ches2010/62250001 \n";
                                    file << "     /62250001.pdf; and a C implementation can be found at https://github.com/veorq/Quark. \n" << endl;
                                }
                                else if(algoName == option5)
                                {
                                    file << "QUARK is a hash function family consisting of three instances, namely U-QUARK,  \n";
                                    file << "     D-QUARK, and S-QUARK. It can be used for message authentication, stream encryption, or  \n";
                                    file << "     authenticated encryption. QUARK is based on a sponge construction, and it is only optimized \n";
                                    file << "     for hardware implementation. More details about the lightweight hash function can be found\n";
                                    file << "     at https://131002.net/quark/quark_full.pdf, and https://www.iacr.org/archive/ches2010/62250001 \n";
                                    file << "     /62250001.pdf; and a C implementation can be found at https://github.com/veorq/Quark. \n" << endl;
                                }
                         }
                         if(!algo_name3.empty())
                         {
                             std::string option1 = "SipHas", option2 = "", option3 = "";
                             std::string algoName = algo_name3.substr(0, 6);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name3 << ":- ";

                                if(algoName == option1)
                                {
                                    file << "SipHash is a keyed hash function with a key length of 128 bits and an output length\n";
                                    file << "     of 64 bits. It is optimized for software implementation and runs fast on a CPU that supports \n";
                                    file << "     64-bit operations only. The target applications of SipHash include network traffic authentication \n";
                                    file << "     and hash-table lookups protected against hash-flooding denial-of-service attacks. More information \n";
                                    file << "     about the SipHash can be found at https://cr.yp.to/siphash/siphash-20120620.pdf, and a Javascript  \n";
                                    file << "     implementation can be found at https://github.com/jedisct1/siphash-js.  \n" << endl;
                                }
                                else if(algoName == option2)
                                {

                                }
                                else if(algoName == option3)
                                {

                                }
                         }
                         if(!algo_name4.empty() && algo_name1.empty())
                         {
                             std::string option1 = "SPECK", option2 = "SIMON", option3 = "Clefi", option4 = "Midor", option5 = "TWINE", option6 = "Picco", option7 = "ChaCh", option8 = "Enoco", option9 = "Grain", option10 = "Trivi", option11 = "MICKE";
                             std::string algoName = algo_name1.substr(0, 5);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name4 << ":- ";

                             if(algoName == option1)
                                {
                                    file << "SPECK is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SPECK has been optimized for performance in software \n";
                                    file << "     implementation. SPECK supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SPECK can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "SIMON is a family of lightweight block ciphers designed by the United States National\n";
                                    file << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
                                    file << "     and computational capabilities are limited. SIMON has been optimized for performance in hardware \n";
                                    file << "     implementation. SIMON supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
                                    file << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SIMON can be  \n";
                                    file << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
                                    file << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "CLEFIA is a lightweight proprietary block cipher algorithm developed by Sony. The \n";
                                    file << "     block cipher is intended to serve as a safe alternative to AES with the flexibility for efficient\n";
                                    file << "     implementation in both hardware and software. CLEFIA supports 128-bit (16 bytes) block size and \n";
                                    file << "     three different key sizes of 128, 192, and 256 bits. More information about CLEFIA can be found at\n";
                                    file << "     https://www.sony.net/Products/cryptography/clefia/about/appendix_01.html, and a C implementation  \n";
                                    file << "     can be found at https://github.com/fedescarpa/clefia. \n" << endl;
                                }
                                else if(algoName == option4)
                                {
                                    file << "Midori, a Japanese word for green, is a 128-bit secret key block cipher that comes \n";
                                    file << "     in two variants, Midori 64 and Midori 128. The 64 and 128 correspond to the different block sizes\n";
                                    file << "     (i.e., Midori 64/128 and Midori 128/128). The two variants of Midori provide acceptable security \n";
                                    file << "     level with optimal energy consumption when implemented in hardware. More information about Midori \n";
                                    file << "     can be found at https://eprint.iacr.org/2015/1142.pdf, and a hardware design of Midori 128 written \n";
                                    file << "     in VHDL can be found at https://github.com/tomirio619/Midori. \n" << endl;
                                }
                                else if(algoName == option5)
                                {
                                    file << "TWINE is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes. The\n";
                                    file << "     cipher is designed to be efficient on both software and hardware. For software implementation, TWINE\n";
                                    file << "     consumes less CPU time and occupies a small ROM space. The cipher is also designed to perform well\n";
                                    file << "     on various types of CPUs, from low-end microcontrollers to high-end CPUs, such as the Intel Core-i\n";
                                    file << "     series. For more information on TWINE, refer to https://wwwljk.imag.fr/membres/Pierre.Karpman/cry_\n";
                                    file << "     intro_tp_twine.pdf. In addition, some information on the C implementation of TWINE can be found at \n";
                                    file << "     https://github.com/dgryski/go-twine.\n" << endl;
                                }
                                else if(algoName == option6)
                                {
                                    file<< "Piccolo is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes.\n";
                                    file << "     The cipher achieves both high security and notably compact implementation in hardware. For example, \n";
                                    file << "     for encryption, the gate equivalent (GE) requirements for the 80 and the 128-bit key modes are only\n";
                                    file << "     683 and 758, respectively; and only 60 additional GEs are required to support the decryption function.\n";
                                    file << "     More information about the structure of Piccolo can be found at https://www.iacr.org/archive/ches2011\n";
                                    file << "     /69170343/69170343.pdf, and a C implementation can be found at https://github.com/Daeinar/piccolo.\n"<< endl;

                                }
                                else if(algoName == option7)
                                {
                                    file << "ChaCha20 is a stream cipher with a 256-bit key and a 96-bit initialization vector(IV).\n";
                                    file << "     Aside from a secret key and an IV, it receives a 128-bit constant anda 32-bit block counter, and \n";
                                    file << "     outputs a 512-bit pseudo-random number. The algorithm utilizes 32-bit word arithmetic additions, \n";
                                    file << "     exclusive ORs (XORs), and cyclic shifts, and is suitable for software implementation. Because it  \n";
                                    file << "     requires little cost for initialization, it can process short messages quickly. Additionally, \n";
                                    file << "     ChaCha20 uses no table lookups, straightforward implementation is secure against cache-timing \n";
                                    file << "     attacks. More information about the stream cipher can be found at https://asecuritysite.com/\n";
                                    file << "     encryption/chacha, and https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf; and a C \n";
                                    file << "     implementation can be found at https://github.com/Ginurx/chacha20-c\n"<< endl;
                                }
                                else if(algoName == option8)
                                {
                                    file << "Enocoro is a stream cipher that consists of two algorithms, Enocoro-80 with 80-bit key \n";
                                    file << "     and Enocoro-128v2 with 128-bit key. The two algorithms claim a level of security corresponding to the \n";
                                    file << "     key length. But the output data is limited to 2^32 bytes and 2^64 bytes, respectively, by fixing the \n";
                                    file << "     key and IV. Unlike other lightweight stream ciphers, this cipher processes in 8-bit units and can \n";
                                    file << "     achieve  processing speeds similar to AES even in software implementation. More information and code\n";
                                    file << "     can be found at https://www.hitachi.com/rd/yrl/crypto/enocoro/index.html. Additional information can \n";
                                    file << "     also be found at https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;

                                }
                                else if(algoName == option9)
                                {
                                    file << "Grain is a hardware-oritented stream cipher. Two algorithms of Grain were selected for\n";
                                    file << "     the eSTREAM portfolio: one with an 80-bit key and a 64-bit IV and the other with a 128-bit key and\n";
                                    file << "     an 80-bit IV. The cipher comprises one bitwise linear feedback shift register and one non-linear\n";
                                    file << "     feedback shift register. Among other lightweight stream ciphers, this stream cipher is superior for \n";
                                    file << "     lightweight hardware implementation. It can achieve certain degrees of parallelism, software \n";
                                    file << "     implementation performs sufficiently for practical uses. For more information on the cipher, we \n";
                                    file << "     refer the user to https://cr.yp.to/streamciphers/grain/desc.pdf, and  https://www.cryptrec.go.jp/\n";
                                    file << "     report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;
                                }
                                else if(algoName == option10)
                                {
                                    file << "Trivium is a stream cipher that is optimized for hardware implementation, which was  \n";
                                    file << "     selected in the eSTREAM portfolio. The cipher accepts an 80-bit key and an 80-bit IV. A keystream \n";
                                    file << "     generated for each pair of key and IV is limited to 264 bits. Trivium has a unique design consisting  \n";
                                    file << "     of three serial non-linear feedback shift registers of different lengths. Based on bitwise operations,\n";
                                    file << "     but having high levels of parallelism, it features lightweight hardware implementation and high \n";
                                    file << "     speeds in software implementation. Nonetheless, Trivium is not suitable for processing short data \n";
                                    file << "     because of its long initialization time. More information can be found at https://eprint.iacr.org/\n";
                                    file << "     2009/431.pdf and  https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. A VHDL \n";
                                    file << "     implementation of Trivium can be found at https://github.com/akshjums/Trivium-Cipher.\n" << endl;
                                }
                                else if(algoName == option11)
                                {
                                    file << "MICKEY 2.0 is a hardware-oriented stream cipher selected in the eSTREAM portfolio. The \n";
                                    file << "     cipher accepts an 80-bit key and an 80-bit IV. The number of available IVs for a fixed key is limited \n";
                                    file << "     up to 240. In addition, the maximum length of a keystream for a pair of key and IV is 240 bits. This  \n";
                                    file << "     stream cipher consists of one linear feedback shift register and one non-linear feedback shift \n";
                                    file << "     register, featuring irregular clock control. Parallel processing is difficult due to the clock \n";
                                    file << "     control mechanism. More information can be found at http://www.ecrypt.eu.org/stream/mickeypf.html.\n";
                                    file << "     \n";
                                    file << "      \n";
                                    file << "     \n" << endl;
                                }
                         }
                         if(!algo_name5.empty())
                         {
                             counter+=1;
                             file << "  " << counter << ". " << algo_name5 << ":- ";
                         }
                         if(!algo_name6.empty())
                         {
                             std::string option1 = "ACORN", option2 = "Ascon", option3 = "CLOC-";
                             std::string algoName = algo_name6.substr(0, 5);
                             counter+=1;
                             file << "  " << counter << ". " << algo_name6 << ":- ";
                              if(algoName == option1)
                                {
                                    file << "ACORN is a stream cipher based authenticated encryption with associated data (AEAD) algorithm.\n";
                                    file << "     It is a 128-bit key and a 128-bit initialization vector (IV) cipher that produces a 128-bit\n";
                                    file << "     authentication tag. While ACORN is a hardware-oriented stream cipher, the version three (ACORN v3),\n";
                                    file << "     which processes one bit per step,  is a bit-based sequential authenticated cipher that is very fast \n";
                                    file << "     in both hardware and software as up to 32 steps can be processed in parallel. More information about \n";
                                    file << "     the cipher can be found at https://competitions.cr.yp.to/round1/acornv1.pdf and  \n";
                                    file << "     https://eprint.iacr.org/2014/157.pdf.\n" << endl;
                                }
                                else if(algoName == option2)
                                {
                                    file << "Ascon is a family of authenticated encryption and hashing algorithms that has been selected\n";
                                    file << "     as the primary choice for lightweight authenticated encryption in the final portfolio of the CAESAR \n";
                                    file << "     competition (2014–2019). The cipher is also currently competing in the NIST Lightweight Cryptography\n";
                                    file << "     competition (2019–). Ascon is designed to be lightweight, easy to implement, and is very fast in both\n";
                                    file << "     hardware and software as up to 32 steps can be processed in parallel, even with added countermeasures \n";
                                    file << "     against side-channel attacks. The recommended key, tag and nonce length for Ascon is 128 bits. More \n";
                                    file << "     information about Ascon can be found at https://ascon.iaik.tugraz.at/ and https://competitions.cr.yp\n";
                                    file << "     .to/round3/asconv12.pdf. \n" << endl;
                                }
                                else if(algoName == option3)
                                {
                                    file << "CLOC, which is pronounced as 'clock', stands for Compact Low-Overhead CFB. It is a\n";
                                    file << "     lightweight authenticated encryption algorithm designed to achieve low overhead computation. \n";
                                    file << "     Although CLOC is designed to handle short input data like 16 bytes, its sequential nature and its \n";
                                    file << "     asymptotic performance for long input data makes it comparable to CCM, EAX and EAX-prime. CLOC uses \n";
                                    file << "     AES for 128-bit block cipher; it is as well defined with a 64-bit block cipher TWINE. More informa-  \n";
                                    file << "     tion about CLOC can be found at http://www.nuee.nagoya-u.ac.jp/labs/tiwata/AE/, and  \n";
                                    file << "     https://eprint.iacr.org/2014/157.pdf.\n" << endl;
                                }
                         }
                         if(algo_name6.empty() && !algo_name2.empty() && (!algo_name1.empty() || !algo_name4.empty()))
                         {
                             file << "\n\  A SUGGESTION " << endl <<endl;
                             file << "  " <<  "  * Authenticated Encryption" << ":- Since your security requirements include confidentiality and/or privacy\n";
                             file << "      as well as integrity, you may consider returning to the main menu to select option 10 in order \n";
                             file << "      to modify your request by including 'Confidentiality & Authenticity' in your security require-\n";
                             file << "      ments. This is because the mechanism that provides 'Confidentiality & Authenticity' is the \n";
                             file << "      authenticated encryption, which can provide message integrity and message origin authentication \n";
                             file << "      in addition to protecting data confidentiality and/or user privacy. \n";
                         }
                           counter = 0;
                }
                   file.close();
            }
            else
            {
                file <<"\n\tFile failed to open!" << endl;
            }
}

void Report::cipher_Info1(std::string algo_name1)
{
	std::string option1 = "SPECK", option2 = "SIMON", option3 = "Clefi", option4 = "Midor", option5 = "TWINE", option6 = "Picco", option7 = "ChaCh", option8 = "Enoco", option9 = "Grain", option10 = "Trivi", option11 = "MICKE";
	std::string algoName = algo_name1.substr(0, 5);
	if(algoName == option1)
	{
        std::cout << "SPECK is a family of lightweight block ciphers designed by the United States National\n";
        std::cout << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
        std::cout << "     and computational capabilities are limited. SPECK has been optimized for performance in software \n";
        std::cout << "     implementation. SPECK supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
        std::cout << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SPECK can be  \n";
        std::cout << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
        std::cout << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
	}
	else if(algoName == option2)
	{
        std::cout << "SIMON is a family of lightweight block ciphers designed by the United States National\n";
        std::cout << "     Security Agency (NSA) to provide security in constrained environments where memory, storage space,\n";
        std::cout << "     and computational capabilities are limited. SIMON has been optimized for performance in hardware \n";
        std::cout << "     implementation. SIMON supports a variety of block and key sizes (i.e., block/key - 32/64, 48/72, 48\n";
        std::cout << "     /96, 64/96, 64/128, 96/96, 96/144, 128/128, 128/192, 128/256). Complete details about SIMON can be  \n";
        std::cout << "     found at at https://eprint.iacr.org/2013/404.pdf. Additionally, the C and Python implementations can \n";
        std::cout << "     be found at https://github.com/inmcm/Simon_Speck_Ciphers.\n"<< endl;
	}
	else if(algoName == option3)
	{
        std::cout << "CLEFIA is a lightweight proprietary block cipher algorithm developed by Sony. The \n";
        std::cout << "     block cipher is intended to serve as a safe alternative to AES with the flexibility for efficient\n";
        std::cout << "     implementation in both hardware and software. CLEFIA supports 128-bit (16 bytes) block size and \n";
        std::cout << "     three different key sizes of 128, 192, and 256 bits. More information about CLEFIA can be found at\n";
        std::cout << "     https://www.sony.net/Products/cryptography/clefia/about/appendix_01.html, and a C implementation  \n";
        std::cout << "     can be found at https://github.com/fedescarpa/clefia. \n" << endl;
	}
	else if(algoName == option4)
	{
        std::cout << "Midori, a Japanese word for green, is a 128-bit secret key block cipher that comes \n";
        std::cout << "     in two variants, Midori 64 and Midori 128. The 64 and 128 correspond to the different block sizes\n";
        std::cout << "     (i.e., Midori 64/128 and Midori 128/128). The two variants of Midori provide acceptable security \n";
        std::cout << "     level with optimal energy consumption when implemented in hardware. More information about Midori \n";
        std::cout << "     can be found at https://eprint.iacr.org/2015/1142.pdf, and a hardware design of Midori 128 written \n";
        std::cout << "     in VHDL can be found at https://github.com/tomirio619/Midori. \n" << endl;
	}
	else if(algoName == option5)
	{
        std::cout << "TWINE is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes. The\n";
        std::cout << "     cipher is designed to be efficient on both software and hardware. For software implementation, TWINE\n";
        std::cout << "     consumes less CPU time and occupies a small ROM space. The cipher is also designed to perform well\n";
        std::cout << "     on various types of CPUs, from low-end microcontrollers to high-end CPUs, such as the Intel Core-i\n";
        std::cout << "     series. For more information on TWINE, refer to https://wwwljk.imag.fr/membres/Pierre.Karpman/cry_\n";
        std::cout << "     intro_tp_twine.pdf. In addition, some information on the C implementation of TWINE can be found at \n";
        std::cout << "     https://github.com/dgryski/go-twine.\n" << endl;
	}
	else if(algoName == option6)
	{
        std::cout << "Piccolo is a lightweight 64-bit block cipher that supports 80 and 128 bit key sizes.\n";
        std::cout << "     The cipher achieves both high security and notably compact implementation in hardware. For example, \n";
        std::cout << "     for encryption, the gate equivalent (GE) requirements for the 80 and the 128-bit key modes are only\n";
        std::cout << "     683 and 758, respectively; and only 60 additional GEs are required to support the decryption function.\n";
        std::cout << "     More information about the structure of Piccolo can be found at https://www.iacr.org/archive/ches2011\n";
        std::cout << "     /69170343/69170343.pdf, and a C implementation can be found at https://github.com/Daeinar/piccolo.\n"<< endl;

	}
	else if(algoName == option7)
	{
        std::cout << "ChaCha20 is a stream cipher with a 256-bit key and a 96-bit initialization vector(IV).\n";
        std::cout << "     Aside from a secret key and an IV, it receives a 128-bit constant anda 32-bit block counter, and \n";
        std::cout << "     outputs a 512-bit pseudo-random number. The algorithm utilizes 32-bit word arithmetic additions, \n";
        std::cout << "     exclusive ORs (XORs), and cyclic shifts, and is suitable for software implementation. Because it  \n";
        std::cout << "     requires little cost for initialization, it can process short messages quickly. Additionally, \n";
        std::cout << "     ChaCha20 uses no table lookups, straightforward implementation is secure against cache-timing \n";
        std::cout << "     attacks. More information about the stream cipher can be found at https://asecuritysite.com/\n";
        std::cout << "     encryption/chacha, and https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf; and a C \n";
        std::cout << "     implementation can be found at https://github.com/Ginurx/chacha20-c\n"<< endl;
	}
	else if(algoName == option8)
	{
        std::cout << "Enocoro is a stream cipher that consists of two algorithms, Enocoro-80 with 80-bit key \n";
        std::cout << "     and Enocoro-128v2 with 128-bit key. The two algorithms claim a level of security corresponding to the \n";
        std::cout << "     key length. But the output data is limited to 2^32 bytes and 2^64 bytes, respectively, by fixing the \n";
        std::cout << "     key and IV. Unlike other lightweight stream ciphers, this cipher processes in 8-bit units and can \n";
        std::cout << "     achieve  processing speeds similar to AES even in software implementation. More information and code\n";
        std::cout << "     can be found at https://www.hitachi.com/rd/yrl/crypto/enocoro/index.html. Additional information can \n";
        std::cout << "     also be found at https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;

	}
	else if(algoName == option9)
	{
        std::cout << "Grain is a hardware-oritented stream cipher. Two algorithms of Grain were selected for\n";
        std::cout << "     the eSTREAM portfolio: one with an 80-bit key and a 64-bit IV and the other with a 128-bit key and\n";
        std::cout << "     an 80-bit IV. The cipher comprises one bitwise linear feedback shift register and one non-linear\n";
        std::cout << "     feedback shift register. Among other lightweight stream ciphers, this stream cipher is superior for \n";
        std::cout << "     lightweight hardware implementation. It can achieve certain degrees of parallelism, software \n";
        std::cout << "     implementation performs sufficiently for practical uses. For more information on the cipher, we \n";
        std::cout << "     refer the user to https://cr.yp.to/streamciphers/grain/desc.pdf, and  https://www.cryptrec.go.jp/\n";
        std::cout << "     report/cryptrec-gl-2003-2016en.pdf. \n"<< endl;
	}
	else if(algoName == option10)
	{
        std::cout << "Trivium is a stream cipher that is optimized for hardware implementation, which was  \n";
        std::cout << "     selected in the eSTREAM portfolio. The cipher accepts an 80-bit key and an 80-bit IV. A keystream \n";
        std::cout << "     generated for each pair of key and IV is limited to 264 bits. Trivium has a unique design consisting  \n";
        std::cout << "     of three serial non-linear feedback shift registers of different lengths. Based on bitwise operations,\n";
        std::cout << "     but having high levels of parallelism, it features lightweight hardware implementation and high \n";
        std::cout << "     speeds in software implementation. Nonetheless, Trivium is not suitable for processing short data \n";
        std::cout << "     because of its long initialization time. More information can be found at https://eprint.iacr.org/\n";
        std::cout << "     2009/431.pdf and  https://www.cryptrec.go.jp/report/cryptrec-gl-2003-2016en.pdf. A VHDL \n";
        std::cout << "     implementation of Trivium can be found at https://github.com/akshjums/Trivium-Cipher.\n" << endl;
	}
	else if(algoName == option11)
	{
        std::cout << "MICKEY 2.0 is a hardware-oriented stream cipher selected in the eSTREAM portfolio. The \n";
        std::cout << "     cipher accepts an 80-bit key and an 80-bit IV. The number of available IVs for a fixed key is limited \n";
        std::cout << "     up to 240. In addition, the maximum length of a keystream for a pair of key and IV is 240 bits. This  \n";
        std::cout << "     stream cipher consists of one linear feedback shift register and one non-linear feedback shift \n";
        std::cout << "     register, featuring irregular clock control. Parallel processing is difficult due to the clock \n";
        std::cout << "     control mechanism. More information can be found at http://www.ecrypt.eu.org/stream/mickeypf.html.\n";
        std::cout << "     \n";
        std::cout << "      \n";
        std::cout << "     \n" << endl;
	}
}

    void Report::cipher_Info2(std::string algo_name2)
    {
        std::string option1 = "PHOTON", option2 = "SPONGE", option3 = "Keccak", option4 = "U-QUAR", option5 = "S-QUAR";
        std::string algoName = algo_name2.substr(0, 6);
        if(algoName == option1)
        {
            std::cout << "PHOTON is a family of lightweight hash functions that come in five different \n";
            std::cout << "     flavors with the following digest sizes: 80, 128, 160, 224 and 256 bits. PHOTON can be represented \n";
            std::cout << "     in this format: PHOTON-n/r/r', where n is the output length in bits, r represents the input block  \n";
            std::cout << "     length, and r' is the output block length. Thus, the five variants are PHOTON-80/20/16, PHOTON-128  \n";
            std::cout << "     /16/16, PHOTON-160/36/36, PHOTON-224/32/32, and PHOTON-256/32/32. The lightweight hash function is \n";
            std::cout << "     suitable for extremely constrained devices such as passive RFID tags. Although it is optimized for \n";
            std::cout << "     hardware implementation, PHOTON can equally be implemented in software. More details about PHOTON \n";
            std::cout << "     can be found at https://eprint.iacr.org/2011/609.pdf and https://pdfs.semanticscholar.org/63d1/ \n";
            std::cout << "     7f64d7a7d5b1bcd199c2569334e7194e40e1.pdf.\n"<< endl;
        }
        else if(algoName == option2)
        {
            std::cout << "SPONGENT a family of lightweight hash functions based on a sponge construction   \n";
            std::cout << "     instantiated with a PRESENT-type permutation. SPONGENT can produce hash sizes of 88, 128, 160, 224,\n";
            std::cout << "     and 256 bit. It offers a lot of flexibility in terms of serialization degree and speed. For more\n";
            std::cout << "     information about SPONGENT, refer to https://www.iacr.org/archive/ches2011/69170311/69170311.pdf\n"<< endl;
        }
        else if(algoName == option3)
        {
            std::cout << "Keccak is a set of seven permutation functions called Keccak-f[b], which can be \n";
            std::cout << "     used to construct a stream cipher, a cryptographic hash function, a Pseudo Random Number Generator \n";
            std::cout << "     (PRNG), Message Authentication Code (MAC) or an Authenticated Encryption Associated Data (AEAD)  \n";
            std::cout << "     algorithm. The 'b' represents the width which is between 25 and 1600 by multiplicative steps of 2\n";
            std::cout << "     (b 25, 50, 100, 200, 400, 800, 1,600). The functions relevant to the lightweight cryptography are  \n";
            std::cout << "     Keccak-f[100], Keccak-f[200], and Keccak-f[400]. More information about Keccak can be found at \n";
            std::cout << "     https://keccak.team/ and https://www.iacr.org/archive/eurocrypt2013/78810311/78810311.pdf.  \n" << endl;
        }
        else if(algoName == option4)
        {
            std::cout << "QUARK is a hash function family consisting of three instances, namely U-QUARK,  \n";
            std::cout << "     D-QUARK, and S-QUARK. It can be used for message authentication, stream encryption, or  \n";
            std::cout << "     authenticated encryption. QUARK is based on a sponge construction, and it is only optimized \n";
            std::cout << "     for hardware implementation. More details about the lightweight hash function can be found\n";
            std::cout << "     at https://131002.net/quark/quark_full.pdf, and https://www.iacr.org/archive/ches2010/62250001 \n";
            std::cout << "     /62250001.pdf; and a C implementation can be found at https://github.com/veorq/Quark. \n" << endl;
        }
        else if(algoName == option5)
        {
            std::cout << "QUARK is a hash function family consisting of three instances, namely U-QUARK,  \n";
            std::cout << "     D-QUARK, and S-QUARK. It can be used for message authentication, stream encryption, or  \n";
            std::cout << "     authenticated encryption. QUARK is based on a sponge construction, and it is only optimized \n";
            std::cout << "     for hardware implementation. More details about the lightweight hash function can be found\n";
            std::cout << "     at https://131002.net/quark/quark_full.pdf, and https://www.iacr.org/archive/ches2010/62250001 \n";
            std::cout << "     /62250001.pdf; and a C implementation can be found at https://github.com/veorq/Quark. \n" << endl;
        }
    }

    void Report::cipher_Info3(std::string algo_name3)
    {
        std::string option1 = "SipHas", option2 = "", option3 = "";
        std::string algoName = algo_name3.substr(0, 6);
        if(algoName == option1)
        {
            std::cout << "SipHash is a keyed hash function with a key length of 128 bits and an output length\n";
            std::cout << "     of 64 bits. It is optimized for software implementation and runs fast on a CPU that supports \n";
            std::cout << "     64-bit operations only. The target applications of SipHash include network traffic authentication \n";
            std::cout << "     and hash-table lookups protected against hash-flooding denial-of-service attacks. More information \n";
            std::cout << "     about the SipHash can be found at https://cr.yp.to/siphash/siphash-20120620.pdf, and a Javascript  \n";
            std::cout << "     implementation can be found at https://github.com/jedisct1/siphash-js.  \n" << endl;
        }
        else if(algoName == option2)
        {

        }
        else if(algoName == option3)
        {

        }
    }

    void Report::cipher_Info6(std::string algo_name6)
    {
        std::string option1 = "ACORN", option2 = "Ascon", option3 = "CLOC-";
        std::string algoName = algo_name6.substr(0, 5);
        if(algoName == option1)
        {
            std::cout << "ACORN is a stream cipher based authenticated encryption with associated data (AEAD) algorithm.\n";
            std::cout << "     It is a 128-bit key and a 128-bit initialization vector (IV) cipher that produces a 128-bit\n";
            std::cout << "     authentication tag. While ACORN is a hardware-oriented stream cipher, the version three (ACORN v3),\n";
            std::cout << "     which processes one bit per step,  is a bit-based sequential authenticated cipher that is very fast \n";
            std::cout << "     in both hardware and software as up to 32 steps can be processed in parallel. More information about \n";
            std::cout << "     the cipher can be found at https://competitions.cr.yp.to/round1/acornv1.pdf and  \n";
            std::cout << "     https://eprint.iacr.org/2014/157.pdf.\n" << endl;
        }
        else if(algoName == option2)
        {
            std::cout << "Ascon is a family of authenticated encryption and hashing algorithms that has been selected\n";
            std::cout << "     as the primary choice for lightweight authenticated encryption in the final portfolio of the CAESAR \n";
            std::cout << "     competition (2014–2019). The cipher is also currently competing in the NIST Lightweight Cryptography\n";
            std::cout << "     competition (2019–). Ascon is designed to be lightweight, easy to implement, and is very fast in both\n";
            std::cout << "     hardware and software as up to 32 steps can be processed in parallel, even with added countermeasures \n";
            std::cout << "     against side-channel attacks. The recommended key, tag and nonce length for Ascon is 128 bits. More \n";
            std::cout << "     information about Ascon can be found at https://ascon.iaik.tugraz.at/ and https://competitions.cr.yp\n";
            std::cout << "     .to/round3/asconv12.pdf. \n" << endl;
        }
        else if(algoName == option3)
        {
            std::cout << "CLOC, which is pronounced as 'clock', stands for Compact Low-Overhead CFB. It is a \n";
            std::cout << "     lightweight authenticated encryption algorithm designed to achieve low overhead computation.  \n";
            std::cout << "     Although CLOC is designed to handle short input data like 16 bytes, its sequential nature and its   \n";
            std::cout << "     asymptotic performance for long input data makes it comparable to CCM, EAX and EAX-prime. CLOC uses \n";
            std::cout << "     AES for 128-bit block cipher; it is as well defined with a 64-bit block cipher TWINE. More informa-  \n";
            std::cout << "     tion about CLOC can be found at http://www.nuee.nagoya-u.ac.jp/labs/tiwata/AE/, and  \n";
            std::cout << "     https://eprint.iacr.org/2014/157.pdf.\n" << endl;
        }
    }

    bool Report::check_BP_condition(const char* path_to_file_x, std::ostream& combined_file)
    {
        std::ifstream file_x(path_to_file_x);
        if(file_x)
        {
            combined_file << file_x.rdbuf();
            return true ;
        }
        else
        {
            return false ;
        }
    }

    bool Report::check_BP_condition2(const char* path_to_file_x, std::ostream& combined_file, std::string s)
    {
        std::ifstream file_x(path_to_file_x);
        if(file_x && s == "Yes")
        {
            combined_file << file_x.rdbuf();
            return true ;
        }
        else
        {
            return false ;
        }
    }

    bool Report::check_BP_condition3(const char* path_to_file_x, std::ostream& combined_file, std::string s1, std::string s2)
    {
        std::ifstream file_x(path_to_file_x);
        if(file_x && s1 == s2)
        {
            combined_file << file_x.rdbuf();
            return true ;
        }
        else
        {
            return false ;
        }
    }

    bool Report::mergeFiles(const char* path_to_file_x, std::ostream& combined_file)
    {
        std::ifstream file_x(path_to_file_x);
        if(file_x)
        {
            combined_file << file_x.rdbuf();
            return true ;
        }
        else
        {
            return false ;
        }
    }
